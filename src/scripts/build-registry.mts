import { exec } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import { rimraf } from "rimraf";
import { RegistryItem, registrySchema } from "shadcn/schema";

import { cleanFilePath, rewriteItemImports } from "@/lib/registry/generate";
import { RegistryItemFile } from "@/types/shadcn-patch";
import { getBundleFromItem, getBundleImportPath } from "@/utils/registry/bundle";

try {
  // Clean up public/r directory before building to prevent stale files
  console.log("üóëÔ∏è  Cleaning up public/r (registry) directory...");
  rimraf.sync(path.join(process.cwd(), "public/r"));

  console.log("üì¶  Building registry/__index__.tsx...");
  await buildRegistryIndex();

  console.log("üìÑ  Building registry...");
  await buildRegistryJsonFile();
  await buildRegistry();
  console.log("   ‚úÖ  Registry built successfully");

  console.log("‚úÖ Build completed successfully");
} catch (error) {
  console.error(error);
  process.exit(1);
}

async function buildRegistryIndex() {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

type RegistryItemWithComponent = RegistryItem & {
  component: React.LazyExoticComponent<React.ComponentType<any>>;
};

export const Index: Record<string, RegistryItemWithComponent> = {`;

  // 1. Dynamically import the registry.
  const { registry: importedRegistry } = await import("@/registry/index");

  // 2. Validate the registry schema.
  const parseResult = registrySchema.safeParse(importedRegistry);
  if (!parseResult.success) {
    console.error(`‚ùå  Registry validation failed`);
    console.error(parseResult.error.format());
    throw new Error(`Invalid registry schema for imported registry index`);
  }

  const registry = parseResult.data;

  for (const item of registry.items) {
    // Skip items without files
    if (!item.files || item.files.length === 0) {
      continue;
    }

    try {
      getBundleFromItem(item);
    } catch {
      console.warn(
        `‚ö†Ô∏è  Skipping __index__ entry for "${item.name}" (type: ${item.type}) - missing meta.bundle`
      );
      continue;
    }

    const componentPath = item.files[0]?.path ? getBundleImportPath(item, item.files[0].path) : "";

    const isPreviewable = item.type === "registry:example" || item.type === "registry:block";

    // 3. Append the registry item entry to the index.
    index += `
  "${item.name}": {
    name: "${item.name}",
    type: "${item.type}",
    title: "${item.title ?? ""}",
    description: "${item.description ?? ""}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${item.files.map((file) => {
      const filePath = buildFilePath(item, typeof file === "string" ? file : file.path);
      const resolvedFilePath = path.resolve(filePath);
      return typeof file === "string"
        ? `"${resolvedFilePath}"`
        : `{
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`;
    })}],
    component: ${
      // Only include the LazyLoaded component if the item is previewable.
      componentPath && isPreviewable
        ? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
      return { default: mod.default || mod[exportName] }
    })`
        : "null"
    },
    categories: ${JSON.stringify(item.categories)},
    meta: ${JSON.stringify(item.meta)},
  },`;
  }

  index += `
  }`;

  console.log(`#Ô∏è‚É£  ${Object.keys(registry.items).length} items found`);

  // 4. Write unified index.
  const registryIndexPath = path.join(process.cwd(), "src/registry/__index__.tsx");
  rimraf.sync(registryIndexPath);
  await fs.writeFile(registryIndexPath, index);
}

async function buildRegistryJsonFile() {
  // 1. Import the registry index.
  const { registry: importedRegistry } = await import("@/registry/index");

  // 2. Validate the registry schema.
  const parseResult = registrySchema.safeParse(importedRegistry);
  if (!parseResult.success) {
    console.error(`‚ùå  Registry validation failed`);
    console.error(parseResult.error.format());
    throw new Error(`Invalid registry schema for imported registry index`);
  }

  const registry = parseResult.data;

  // 3. Fix the path for registry items.
  const fixedRegistry = {
    $schema: "https://ui.shadcn.com/schema/registry.json",
    ...registry,
    items: registry.items
      .filter((item) => item.type !== "registry:example") // Skip examples
      .map((item) => {
        // Skip bundle prefix for default "index" item
        if (item.name === "index") {
          return item;
        }

        const files = item.files?.map((file) => {
          const basePath = typeof file === "string" ? file : file.path;
          return {
            ...file,
            path: buildFilePath(item, basePath),
          };
        });

        return {
          ...item,
          files,
        };
      }),
  };

  // 4. Create the output directory and write registry.json.
  const outputDir = path.join(process.cwd(), "public/r");
  await fs.mkdir(outputDir, { recursive: true });

  // 5. Write registry.json to output directory and format it.
  const registryJsonPath = path.join(outputDir, "registry.json");
  await fs.writeFile(registryJsonPath, JSON.stringify(fixedRegistry, null, 2));
  await new Promise<void>((resolve, reject) => {
    exec(`prettier --write "${registryJsonPath}"`, (error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  });

  // 6. Write root level registry.json file needed by shadcn build.
  const rootRegistryJsonPath = path.join(process.cwd(), `registry.json`);
  await fs.writeFile(rootRegistryJsonPath, JSON.stringify(fixedRegistry, null, 2));
}

async function buildRegistry() {
  return new Promise((resolve, reject) => {
    const jsonFilePath = "registry.json";
    const outputDir = "public/r";

    const process = exec(`pnpm dlx shadcn build ${jsonFilePath} --output ${outputDir}`);
    process.on("exit", async (code) => {
      if (code === 0) {
        // Post-process the generated JSON files to remove registry/${bundle} prefix
        // Not sure if this is needed, since shadcn dropped it in the last registry refactor.
        console.log("üìù  Cleaning up paths in generated JSON files...");
        await cleanupGeneratedPaths("public/r");

        resolve(undefined);
      } else {
        reject(new Error(`Process exited with code ${code}`));
      }
    });
  });
}

/**
 * Build full file path, respecting absolute paths and relative paths with bundle prefix for registry structure.
 *
 * If the bundle is missing and not required for the given item type,
 * this will still root the path under src/registry but skip the bundle segment.
 */
function buildFilePath(item: RegistryItem, filePath: string): string {
  // If user already passed an absolute-ish src path, respect it
  if (filePath.startsWith("src/")) {
    return filePath;
  }

  const bundle = getBundleFromItem(item);

  // No bundle: still root under src/registry, just skip the bundle segment
  if (!bundle) {
    return `src/registry/${filePath}`;
  }

  // Bundled items keep existing behavior
  return `src/registry/${bundle}/${filePath}`;
}

/**
 * Clean up generated paths in the target directory.
 * Post-process the generated JSON files to remove registry/${bundle} prefix
 *
 * This is not (might not be*) needed anymore, since shadcn dropped the bundle prefix in the last registry refactor.
 */
async function cleanupGeneratedPaths(targetDir: string) {
  const dir = path.join(process.cwd(), targetDir);

  // Get all JSON files in the target directory
  const files = await fs.readdir(dir);
  const jsonFiles = files.filter((file) => file.endsWith(".json"));

  for (const file of jsonFiles) {
    const filePath = path.join(dir, file);
    const content = await fs.readFile(filePath, "utf-8");
    const json = JSON.parse(content);

    // Skip if no bundle metadata (global items don't need path cleanup)
    const bundle = json.meta?.bundle;
    if (!bundle) {
      continue;
    }

    if (json.files) {
      // Build a mapping of source paths to target paths for this block
      const pathMappings = new Map<string, string>();

      json.files.forEach((file: RegistryItemFile) => {
        if (typeof file === "object" && file.path && file.target) {
          // Map the source registry path to the target path
          const sourcePath = file.path.replace(
            new RegExp(`^src/registry/${bundle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/`),
            ""
          );
          pathMappings.set(sourcePath, file.target);
        }
      });

      json.files = json.files.map((file: RegistryItemFile) => {
        if (typeof file === "object" && file.path) {
          // Remove bundle prefix and normalize paths using shared helper
          file.path = cleanFilePath(file.path, bundle);

          // Clean up imports in the content field using the path mappings
          if (file.content) {
            file.content = rewriteItemImports(file.content, bundle, pathMappings);
          }
        }
        return file;
      });
    }

    // Write the cleaned JSON back and format it.
    await fs.writeFile(filePath, JSON.stringify(json, null, 2));
    await new Promise<void>((resolve, reject) => {
      exec(`prettier --write "${filePath}"`, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  console.log(`‚ú®  Cleaned paths in ${jsonFiles.length} files`);
}
