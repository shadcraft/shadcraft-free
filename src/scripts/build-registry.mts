import { exec } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import { rimraf } from "rimraf";
import { registrySchema } from "shadcn/schema";

import { cleanFilePath, rewriteItemImports } from "@/lib/registry/generate";
import { RegistryItemFile } from "@/types/shadcn-patch";
import { getBundleFromItem, getBundleImportPath, getBundlePath } from "@/utils/registry/bundle";

// This is the main registry index file.
// Contains all the items from all bundles.
// import { registry } from "@/registry/index";

async function buildRegistryIndex() {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

type RegistryItemWithComponent = RegistryItem & {
  component: React.LazyExoticComponent<React.ComponentType<any>>;
};

export const Index: Record<string, RegistryItemWithComponent> = {`;

  const { registry: importedRegistry } = await import("@/registry/index");
  const parseResult = registrySchema.safeParse(importedRegistry);
  if (!parseResult.success) {
    console.error(`‚ùå Registry validation failed`);
    console.error(parseResult.error.format());
    throw new Error(`Invalid registry schema for imported registry index`);
  }

  const registry = parseResult.data;

  for (const item of registry.items) {
    const files = item.files ?? [];
    // Skip items without files
    if (files.length === 0) {
      continue;
    }

    try {
      getBundleFromItem(item);
    } catch {
      console.warn(
        `‚ö†Ô∏è  Skipping __index__ entry for "${item.name}" (type: ${item.type}) - missing meta.bundle`
      );
      continue;
    }

    const componentPath = files[0].path
      ? getBundleImportPath(item, files[0].path.replace(/\.(tsx?|jsx?)$/, ""))
      : "";

    index += `
  "${item.name}": {
    name: "${item.name}",
    type: "${item.type}",
    title: "${item.title ?? ""}",
    description: "${item.description ?? ""}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${files.map((file) => {
      const filePath = getBundlePath(item, typeof file === "string" ? file : file.path);
      const resolvedFilePath = path.resolve(filePath);
      return typeof file === "string"
        ? `"${resolvedFilePath}"`
        : `{
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`;
    })}],
    component: ${
      componentPath
        ? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
      return { default: mod.default || mod[exportName] }
    })`
        : "null"
    },
    categories: ${JSON.stringify(item.categories)},
    meta: ${JSON.stringify(item.meta)},
  },`;
  }

  index += `
  }`;

  console.log(`#Ô∏è‚É£  ${Object.keys(registry.items).length} items found`);

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "src/registry/__index__.tsx"));
  await fs.writeFile(path.join(process.cwd(), "src/registry/__index__.tsx"), index);
}

async function buildRegistryJsonFile() {
  const { registry: importedRegistry } = await import("@/registry/index");
  const parseResult = registrySchema.safeParse(importedRegistry);
  if (!parseResult.success) {
    console.error(`‚ùå Registry validation failed`);
    console.error(parseResult.error.format());
    throw new Error(`Invalid registry schema for imported registry index`);
  }

  const registry = parseResult.data;

  // Add bundle prefix to file paths for the build to work (only if bundle exists)
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      // Skip bundle prefix for default "index" item
      if (item.name === "index") {
        return item;
      }

      const files = item.files?.map((file) => {
        const basePath = typeof file === "string" ? file : file.path;
        return {
          ...file,
          path: getBundlePath(item, basePath),
        };
      });

      return {
        ...item,
        files,
      };
    }),
  };

  // Create the output directory and write registry.json.
  const outputDir = path.join(process.cwd(), "public/r");
  await fs.mkdir(outputDir, { recursive: true });

  // Write registry.json to output directory and format it.
  const registryJsonPath = path.join(outputDir, "registry.json");
  await fs.writeFile(registryJsonPath, JSON.stringify(fixedRegistry, null, 2));
  await new Promise<void>((resolve, reject) => {
    exec(`prettier --write "${registryJsonPath}"`, (error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  });

  // Write root level registry.json file needed by shadcn build.
  const rootRegistryJsonPath = path.join(process.cwd(), `registry.json`);
  await fs.writeFile(rootRegistryJsonPath, JSON.stringify(fixedRegistry, null, 2));
}

async function buildRegistry() {
  return new Promise((resolve, reject) => {
    const process = exec(`pnpm dlx shadcn build registry.json --output public/r`);
    process.on("exit", async (code) => {
      if (code === 0) {
        // Post-process the generated JSON files to remove registry/${bundle} prefix
        // Not sure if this is needed, since shadcn dropped it in the last registry refactor.
        console.log("üìù Cleaning up paths in generated JSON files...");
        await cleanupGeneratedPaths("public/r");

        resolve(undefined);
      } else {
        reject(new Error(`Process exited with code ${code}`));
      }
    });
  });
}

async function cleanupGeneratedPaths(targetDir: string) {
  const dir = path.join(process.cwd(), targetDir);

  // Get all JSON files in the target directory
  const files = await fs.readdir(dir);
  const jsonFiles = files.filter((file) => file.endsWith(".json"));

  for (const file of jsonFiles) {
    const filePath = path.join(dir, file);
    const content = await fs.readFile(filePath, "utf-8");
    const json = JSON.parse(content);

    // Skip if no bundle metadata (global items don't need path cleanup)
    const bundle = json.meta?.bundle;
    if (!bundle) {
      continue;
    }

    if (json.files) {
      // Build a mapping of source paths to target paths for this block
      const pathMappings = new Map<string, string>();

      json.files.forEach((file: RegistryItemFile) => {
        if (typeof file === "object" && file.path && file.target) {
          // Map the source registry path to the target path
          const sourcePath = file.path.replace(
            new RegExp(`^src/registry/${bundle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/`),
            ""
          );
          pathMappings.set(sourcePath, file.target);
        }
      });

      json.files = json.files.map((file: RegistryItemFile) => {
        if (typeof file === "object" && file.path) {
          // Remove bundle prefix and normalize paths using shared helper
          file.path = cleanFilePath(file.path, bundle);

          // Clean up imports in the content field using the path mappings
          if (file.content) {
            file.content = rewriteImports(file.content, bundle, pathMappings);
          }
        }
        return file;
      });
    }

    // Write the cleaned JSON back and format it.
    await fs.writeFile(filePath, JSON.stringify(json, null, 2));
    await new Promise<void>((resolve, reject) => {
      exec(`prettier --write "${filePath}"`, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  console.log(`‚ú® Cleaned paths in ${jsonFiles.length} files`);
}

function rewriteImports(
  content: string,
  bundle: string,
  pathMappings: Map<string, string>
): string {
  // Use the shared rewrite function from generate.ts
  return rewriteItemImports(content, bundle, pathMappings);
}

try {
  console.log("üóÇÔ∏è Building registry/__index__.tsx...");
  await buildRegistryIndex();

  console.log("üíÖ Building registry.json...");
  await buildRegistryJsonFile();

  console.log("üèóÔ∏è Building registry...");
  await buildRegistry();
} catch (error) {
  console.error(error);
  process.exit(1);
}
